using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SimpleBuilder
{
    [Generator]
    public class BuilderGenerator : IIncrementalGenerator
    {
        private const string BuilderAttribute = "SimpleBuilder.MakeBuilderAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (s, _) => IsSyntaxTargetForGeneration(s), // select classes with attributes
                    static (ctx, _) => GetSemanticTargetForGeneration(ctx)) // sect the enum with the [MakeBuilder] attribute
                .Where(static m => m is not null)!;

            // Combine the selected enums with the `Compilation`
            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
                = context.CompilationProvider.Combine(classDeclarations.Collect());

            // Generate the source using the compilation and classes
            context.RegisterSourceOutput(
                compilationAndClasses,
                static (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
            => node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;


        private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            // we know the node is a ClassDeclarationSyntax thanks to IsSyntaxTargetForGeneration
            var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

            // loop through all the attributes on the method
            foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
            {
                foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
                {
                    if (context.SemanticModel.GetSymbolInfo(attributeSyntax)
                            .Symbol is not IMethodSymbol attributeSymbol)
                    {
                        // weird, we couldn't get the symbol, ignore it
                        continue;
                    }

                    INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                    string fullName = attributeContainingTypeSymbol.ToDisplayString();

                    // Is the attribute the [MakeBuilder] attribute?
                    if (fullName == BuilderAttribute)
                    {
                        // return the enum
                        return classDeclarationSyntax;
                    }
                }
            }

            // we didn't find the attribute we were looking for
            return null;
        }

        private static void Execute(
            Compilation compilation,
            ImmutableArray<ClassDeclarationSyntax> classes,
            SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty)
            {
                // nothing to do yet
                return;
            }

            // I'm not sure if this is actually necessary, but `[LoggerMessage]` does it, so seems like a good idea!
            var distinctClasses = classes.Distinct();

            // Convert each ClassDeclarationSyntax to an BuilderToGenerate
            var buildersToGenerate = GetTypesToGenerate(
                compilation,
                distinctClasses,
                context.CancellationToken);

            // If there were errors in the ClassDeclarationSyntax, we won't create an
            // BuilderToGenerate for it, so make sure we have something to generate
            if (buildersToGenerate.Count > 0)
            {
                foreach (var builderToGenerate in buildersToGenerate)
                {
                    var fileName = OnlyName(builderToGenerate.BuilderName) + ".cs";

                    // Generate the source code for the builder
                    string source = GenerateSource(builderToGenerate);

                    // Add the source code to the output
                    context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private static string GenerateSource(BuilderToGenerate builder)
        {
            var builderClassName = OnlyName(builder.BuilderName);
            var underBuilderClassName = OnlyName(builder.ClassUnderBuilder.Name);
            var properties = builder.Properties;
            var code = new CodeWriter();

            code.AppendLine("//This file was generated by simple builder");
            code.AppendLine("using System;");
            code.AppendLine();
            code.AppendLine();
            using (code.BeginScope($"namespace {builder.ClassUnderBuilder.FullNamespace()}"))
            {
                using (code.BeginScope($"class {builderClassName}"))
                {
                    code.AppendLine($@"private {underBuilderClassName} _instance;");
                    code.AppendLine();
                    using (code.BeginScope($@"private {builderClassName}()"))
                    {
                        using (code.BeginScope(
                                   $@"_instance = new {underBuilderClassName}()",
                                   true))
                        {
                            foreach (var property in properties)
                            {
                                code.AppendLine($@"{property.Name} = default,");
                            }
                        }
                    }

                    code.AppendLine();
                    using (code.BeginScope($@"public static {builderClassName} CreateDefault()"))
                    {
                        code.AppendLine($"return new {builderClassName}();");
                    }

                    code.AppendLine();
                    using (code.BeginScope($"public {underBuilderClassName} Build()"))
                    {
                        code.AppendLine("return _instance;");
                    }

                    foreach (var property in properties.ToList())
                    {
                        BuildProperty(code, property, builderClassName);
                    }
                }
            }

            return code.ToString();
        }

        static List<BuilderToGenerate> GetTypesToGenerate(
            Compilation compilation,
            IEnumerable<ClassDeclarationSyntax> classes,
            CancellationToken ct)
        {
            // Create a list to hold our output
            var buildersToGenerate = new List<BuilderToGenerate>();
            // Get the semantic representation of our marker attribute
            INamedTypeSymbol? builderAttribute =
                compilation.GetTypeByMetadataName(BuilderAttribute);

            if (builderAttribute is null)
            {
                // If this is null, the compilation couldn't find the marker attribute type
                // which suggests there's something very wrong! Bail out..
                return buildersToGenerate;
            }

            foreach (var classDeclarationSyntax in classes)
            {
                // stop if we're asked to
                ct.ThrowIfCancellationRequested();

                // Get the semantic representation of the class syntax
                SemanticModel semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                {
                    // something went wrong, bail out
                    continue;
                }

                // Get the full type name of the class e.g. TestClass,
                // or OuterClass<T>.TestClass if it was nested in a generic type (for example)
                var classUnderBuilder = classSymbol;

                // Get all the properties in the class
                var properties = classSymbol.ReadWriteScalarProperties();


                // Create an EnumToGenerate for use in the generation phase
                buildersToGenerate.Add(new BuilderToGenerate(classUnderBuilder, properties.ToList()));
            }

            return buildersToGenerate;
        }

        private static void BuildProperty(CodeWriter code, IPropertySymbol property, string builderClassName)
        {
            using (code.BeginScope($"public {builderClassName} With{property.Name}({property.Type} newValue)"))
            {
                code.AppendLine($"_instance.{property.Name} = newValue;");
                code.AppendLine("return this;");
            }
        }

        private static string OnlyName(string fullName)
        {
            return fullName.Substring(fullName.LastIndexOf(".", StringComparison.InvariantCultureIgnoreCase) + 1);
        }
    }
}